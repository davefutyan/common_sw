<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Common Software: CHEOPS make utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cheops-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Common Software
   &#160;<span id="projectnumber">05</span>
   </div>
   <div id="projectbrief">Common Software for CHEOPS SOC - C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CHEOPS make utility</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module provides a make utility to build the CHEOPS SOC software.  
<a href="#details">More...</a></p>
<p>This module provides a make utility to build the CHEOPS SOC software. </p>
<dl class="section author"><dt>Author</dt><dd>Reiner Rohlfs UGE</dd></dl>
<ul>
<li><p class="startli"><b> Introduction </b></p>
<p class="startli">The goal of the design of this make utility is to provide an easy to use make. Therefore all build rules are defined in a common file called <b>Makefile</b>. This Makefile is identical for all modules and should not be modified by the developer of a module. The module dependent definitions, like the libraries and programs to be build and their dependencies are defined in a module specific file called <b>makecheops</b>. <br />
 A more detailed description of this makecheops file is provided below.</p>
<p class="startli">Only a limited set of .PHONY targets are provided. These are</p><ul>
<li>make <b>all</b> or just make</li>
<li>make <b>clean</b> </li>
<li>make <b>install</b> </li>
<li>make <b>unit_test</b> </li>
<li>make <b>functional_test</b> </li>
<li>make <b>integration_test</b> </li>
<li>make <b>performance_test</b> </li>
<li>make <b>tests</b> </li>
<li>make <b>coverage</b> </li>
<li>make <b>coverage_jenkins</b> </li>
<li>make <b>doc</b> </li>
<li>make <b>make_update</b> </li>
<li>make <b>release</b> </li>
</ul>
<p class="startli">For a detailed description see <b> Implemented .PHONY targets </b> below.</p>
</li>
<li><p class="startli"><b> The directory structure of a module </b></p>
<p class="startli">This make utility expects a directory structure of a module as defined in the <a href="http://www.isdc.unige.ch/svn-cheops/02_system_engineering/documents/ecss/software_engineering_guideline/CHEOPS-UGE-SOC-ST-001_software_engineering_guideline.pdf">engineering standards</a>. The sub-directories of a module directory are:</p><ul>
<li><b>src</b> to host the source code files *.cxx</li>
<li><b>include</b> to host the header files *.hxx</li>
<li><b>obj</b> to host the object files *.o</li>
<li><b>python</b> to host Python source code files *.py</li>
<li><b>bin</b> to host the executables</li>
<li><b>lib</b> to host the libraries *.so or *.dylib</li>
<li><b>conf</b> to host the configurations files *.xml</li>
<li><b>resourses</b> to host the resources of the module, for example the fits schema files of the fits_data_model module or the job-order files</li>
<li><b>doxygen</b> to host source code independent documentation files for doxygen</li>
<li><b>doxygen/python</b> to host Python specific documentation</li>
<li><b>doxygen/cxx</b> to host C++ specific documentation</li>
<li><b>unit_test/src</b> to host the source code of the unit tests *.cxx</li>
<li><b>unit_test/obj</b> to host the object files of the unit test *.o</li>
<li><b>unit_test/bin</b> to host the unit test programs</li>
<li><b>unit_test/python</b> to host the source code of Python unit tests *.py</li>
<li><b>unit_test/resources</b> to host the resources or the test input data of the unit tests</li>
<li><b>unit_test/result</b> to host the results or the test output data of the unit tests</li>
<li><b> tests/[functional | integration | performance]/bin</b> to host the test scripts</li>
<li><b> tests/[functional | integration | performance]/conf</b> to host configurations files *.xml of the tests</li>
<li><b> tests/[functional | integration | performance]/resources</b> to host job-order files of the tests</li>
<li><b> tests/[functional | integration | performance]/output</b> to host the output data and log files of the tests</li>
</ul>
<p class="startli"><br />
</p>
</li>
<li><p class="startli"><b> Environment variables </b> <br />
 This make utility uses 4 environment variables. These are</p><ol type="1">
<li><p class="startli"><b>CHEOPS_SW</b> </p>
<p class="startli">It defines the base directory of an installation area. The software will be copied into sub-directories by invoking <b>make install</b>. The directory and its sub-directories will be created if they do not exist.</p>
</li>
<li><p class="startli"><b>EXT_LIB_DIRS</b> </p>
<p class="startli">In case external libraries as boost, xsd or cfitsio are installed in a location where the compiler does not find them automatically, the path to the libraries can be defined by this environment variable. Each directory has to be preceded by "-L". For example: </p><pre>
      export EXT_LIB_DIRS="-L/usr/local/something -L/home/name/libs"
      </pre></li>
<li><p class="startli"><b>EXT_INC_DIRS</b> </p>
<p class="startli">In case external libraries as boost, xsd or cfitsio are installed in a location where the compiler does not find the corresponding header files them automatically, the path to the header files can be defined by this environment variable. Each directory has to be preceded by "-I". For example: </p><pre>
      export EXT_INC_DIRS="-I/usr/local/something -I/home/name/include"
      </pre></li>
<li><p class="startli"><b>LD_LIBRARY_PATH</b> (LINUX) or <b>DYLD_LIBRARY_PATH</b> (MAX OS)</p>
<p class="startli">One of the paths, defined by this environment variable has to be ${CHEOPS_SW}/lib For example </p><pre>
      export LD_LIBRARY_PATH=${CHEOPS_SW}/lib:${LD_LIBRARY_PATH}
      </pre></li>
</ol>
<p class="startli">These environment variables have to be set also in Eclipse to be able to compile, to link, to install and to run the software in the Eclipse IDE. <br />
 In addition to the aforementioned environment variables, the directory ${CHEOPS_SW}/python must be added to the <b>PYTHONPATH</b> variable in order to include Python packages installed there in scripts. PYTHONPATH is however not used by the make utility itself.</p>
</li>
<li><p class="startli"><b>The Makefile and the makecheops files</b></p>
<p class="startli">The make utility is composed of two files. Their filenames are:</p><ol type="1">
<li><p class="startli"><b>Makefile</b> </p>
<p class="startli">As already mentioned, this is a common file used by every module. It should not be modified by the developer of a module. The master is located at <b>common_sw/makefiles/resources/Makefile</b>. At the beginning of the development of a new module a copy of this master file has to be located in the base directory of the module.</p>
</li>
<li><p class="startli"><b>makecheops</b> </p>
<p class="startli">Beside the Makefile this module dependent file must exist in the base directory of a module. The Makefile will actually include this makecheops file. It defines the libraries and programs of the module and the object files, used to build the libraries and programs. <br />
 Assume a program called <em>program1</em> should be built from two source files called <em>prog_src1.cxx</em> and <em>prog_src2.cxx</em>. The makecheops file would look like </p><pre>
        EXEC_TARGET1 = program1
        EXEC_OBJECT1 = prog_scr_2.o prog_src2.o
        </pre><p> A detailed description of the make variables, that can be defined in this makecheops file can be found in the following chapter.</p>
</li>
</ol>
</li>
<li><p class="startli"><b> Variable definitions in makecheops </b></p>
<p class="startli">The content of the makecheops file defines which programs and libraries should be built and from which source code they are built. This is done by defining variables. Following variables can be define:</p><ul>
<li><b> Building one or two executables </b><ul>
<li><p class="startli"><b>EXEC_TARGET1</b> = program_name</p>
<p class="startli">defines the file name of the program to be build. It has to be defined without path. But it will be created in the bin directory of the module.</p>
</li>
<li><p class="startli"><b>EXEC_OBJECT1</b> = file1.o file2.o</p>
<p class="startli">defines the object files used to build the EXEC_TARGET1 program. These objects files will be automatically created from the corresponding source files (*.cxx). Therefore the source files must exist in the src sub-directory.</p>
</li>
<li><p class="startli"><b>EXEC_TARGET2</b> = program2_name</p>
<p class="startli">similar as EXEC_TARGET1, but used to build a second program of the same module. It can be ignored, if the module builds just one program or just one library.</p>
</li>
<li><p class="startli"><b>EXEC_OBJECT2</b> = file2_1.o file2_2.o</p>
<p class="startli">similar as EXEC_OBJECT1, but defines the object file to build the second program, defined by EXEC_TARGET2. <br />
</p>
</li>
</ul>
</li>
<li><b>Building a shared library </b><ul>
<li><p class="startli"><b>LIB_TARGET1</b> = example</p>
<p class="startli">It defines the name of the library to be built. The actual filename of the library would be with the above example : libexample.dylib on MAC systems and libexample.so ion LINUX systems. The file will be created in the lib sub-directory of the module. <br />
</p>
</li>
<li><b>LIB_OBJECTS1</b> = file1.o file2.o file3.o <br />
 defines the object files used to build the LIB_TARGET1 library. These objects files will be automatically created from the corresponding source files (*.cxx). Therefore the source files must exist in the src sub-directory.</li>
<li><p class="startli"><b>LIB_TARGET2</b> = example2</p>
<p class="startli">Similar to LIB_TARGET1, it defines the name of the second library to be built. It can be ignored if the module builds only one library.</p>
</li>
<li><b>LIB_OBJECTS2</b> = file2_1.o file2_2.o file2_3.o <br />
 Similar to LIB_OBJECTS1, it defines the object files used to build the LIB_TARGET2 library.</li>
<li><p class="startli"><b>PYLIB_TARGET1</b> = example</p>
<p class="startli">It defines the name of a shared library containing a Python extension module. The created file will have the extension .so, independent of the OS on which the library is built, otherwise Python will not recognize it as an extension module. The file will be created in the lib sub-directory of the module.</p>
</li>
<li><p class="startli"><b>PYLIB_OBJECT1</b> = file1.o file2.o</p>
<p class="startli">It defines the object files used to build the PYLIB_OBJECT1 library. These objects files will be automatically created from the corresponding source files (*.cxx). Therefore the source files must exist in the src sub-directory.</p>
</li>
</ul>
</li>
<li><b> Defining tests </b> <br />
<ul>
<li><p class="startli"><b>CXX_UNIT_TESTS</b> = u_test1 u_test2 u_test3</p>
<p class="startli">defines a list of C++ unit tests. For each name in this list a <br />
 corresponding source file *.cxx is expected in the unit_test/scr sub-directory. The "make unit_test" - item in the chapter "Implemented 
         .PHONY targets" describes how the unit tests are build and how they are executed. <br />
 This variable is used only if the mackecheops file is located in a unit_test directory.</p>
</li>
<li><p class="startli"><b>FUNCTIONAL_TESTS</b> = f_test1 f_test2 f_test3</p>
<p class="startli">defines a list of scripts to run functional tests. This variable should be used in the makecheops file, which is located in tests/functional. The listed scipts themselves have to be located in the tests/functional/bin directory. Calling "make functional_test" will execute the listed functional test scripts.</p>
</li>
<li><p class="startli"><b>PERFORMANCE_TESTS</b> = p_test1 p_test2 p_test3</p>
<p class="startli">defines a list of scripts to run performance tests. This variable should be used in the makecheops file, which is located in tests/performance. The listed scipts themselves have to be located in the tests/performance/bin directory. Calling "make performance_test" will execute the listed performance test scripts.</p>
</li>
<li><p class="startli"><b>INTEGRATION_TESTS</b> = i_test1 i_test2 i_test3</p>
<p class="startli">defines a list of scripts to run integration tests. This variable should be used in the makecheops file, which is located in tests/integration. The listed scipts themselves have to be located in the tests/integration/bin directory. Calling "make integration_test" will execute the listed integration test scripts.</p>
</li>
<li><p class="startli"><b>PYTHON_UNIT_TESTS</b> = test1 test2 test3</p>
<p class="startli">defines a list of unit test Python modules. Each name in the list corresponds to the module name of a Python script located in the sub-directories unit_test/python or unit_test/bin. The "make unit_test" - item in the chapter "Implemented .PHONY targets" describes how the unit tests are build and how they are executed. <br />
 This variable is used only if the mackecheops file is located in a unit_test directory.</p>
</li>
<li><b>UNIT_TESTS_PROG_PARAMS</b> = &ndash;parameter=value <br />
 with this variable command line parameters can be defined. They will be passed to every test program defined by the variable CXX_UNIT_TESTS when the unit test is executed by invoking "make unit_test" or "make coverage".</li>
<li><p class="startli"><b>PYTHON_COVERAGE</b> = package</p>
<p class="startli">defines the Python packages to be included in the unit test coverage reports for Python. If not defined, all packages are included. <br />
</p>
</li>
</ul>
</li>
<li><p class="startli"><b> Installing the module in the $CHEOPS_SW area.</b></p>
<p class="startli">The programs defined by EXEC_TARGET1 and EXEC_TARGET2 will be installed in the ${CHEOPS_SW}/bin directory by invoking the "make install" command. There is no extra definition in the makechops file required. In addition the programs configuration files will be installed in the ${CHEOPS_SW}/conf directory. Therefore for each program a corresponding configuration file called EXEC_TARGET1.xml and EXEC_TARGET2.xml must exist in the conf directory of the module.<br />
 Similar the libraries, which were build are automatically installed in ${CHEOPS_SW}/lib. <br />
 Libraries will have to install also some header files in ${CHEOPS_SW}/include. And some programs may have to install some resource files into ${CHEOPS_SW}/resources. These files have to be defined by two variables:</p><ul>
<li><p class="startli"><b>INSTALL_INCL</b> = file1.hxx file2.hxx</p>
<p class="startli">The files defined by this variable have to be located in the incluce sub-directory of the module and will be copied to ${CHEOPS_SW}/include by invoking "make install"</p>
</li>
<li><p class="startli"><b>INSTALL_RESOURCES</b> = file1.res file2.res file3.res</p>
<p class="startli">The files defined by this variable have to be located in the resource sub-directory of the module and will be copied to ${CHEOPS_SW}/include by invoking "make install"</p>
</li>
<li><p class="startli"><b>INSTALL_PYTHON_PACKAGE</b> = examplepackage</p>
<p class="startli">Copies the Python package with the name defined by this variable into ${CHEOPS_SW}/python. The package must be located directly inside in the module's python directory.</p>
</li>
</ul>
</li>
<li><b> Other sometimes useful variables </b> <br />
<ul>
<li><p class="startli"><b>CLEAN</b> = src/filename.cxx conf/filename.xml</p>
<p class="startli">All files defined by this variable will be delete when "make clean" is called. The filename including the path relative to the base directory of the module has to given. <br />
</p>
</li>
<li><p class="startli"><b>SUBDIRS</b> = dir_1 dir_2</p>
<p class="startli">defines that the target processing should also be executed in sub-directories, in the example above in the sub-directoreis dir_1 and dir_2. For a detailed description of this feature see "Recursive calls of make in sub-directories" <br />
 at the end of this document.</p>
</li>
<li><p class="startli"><b>RELEASE_VERSION</b> = r_c.n</p>
<p class="startli">defines the release version of a product. It should be defined in the makecheops file of the product directory. It is used while the product is released invoking the "make release" command. The value is copied to several places. For example in the release note and in the doxygen documenations and it is used as directory name in the tagged version. The <b>c</b> in the version number should be the development cycle, while <b>n</b> is the nth release in a development cyste.<br />
 <br />
 Since common_sw release 4.4 this variable is also used to set the version number of the excutables and the test programs of the released product.</p>
</li>
</ul>
</li>
</ul>
<p class="startli">Please contact the CHEOPS SOC helpdesk <a href="#" onclick="location.href='mai'+'lto:'+'che'+'op'+'s-s'+'oc'+'-he'+'lp'+'@un'+'ig'+'e.c'+'h'; return false;">cheop<span style="display: none;">.nosp@m.</span>s-so<span style="display: none;">.nosp@m.</span>c-hel<span style="display: none;">.nosp@m.</span>p@un<span style="display: none;">.nosp@m.</span>ige.c<span style="display: none;">.nosp@m.</span>h</a> if you are not able to build your module by defining these variables.</p>
</li>
<li><b>Implemented .PHONY targets </b><ul>
<li><p class="startli">make <b>all</b> or just make</p>
<p class="startli">will build the programs EXEC_TARGET1 and EXEC_TARGET2 and the libraries LIB_TARGET1, LIB_TARGET2 and PYLIB_TARGET1 if these variables are defined. The programs will be stored in the bin sub-directory of the module and the library in the lib sub-directory of the module.</p>
</li>
<li><p class="startli">make <b>clean</b> </p>
<p class="startli">will remove all files, that were created by calling "make" or "make all". In detail the EXEC_TARGET1 and EXEC_TARGET2 programs, the LIB_TARGET1, LIB_TARGET2 and PYLIB_TARGET1 library and all object files (*.o) in the obj sub-directory of the module will be deleted. And the files src/*_versoin.cxx will be deleted as well. In addition it will delete all files defined by the CLEAN variable.</p>
</li>
<li><p class="startli">make <b>install</b> </p>
<p class="startli">will install all necessary files of a module in the ${CHEOPS_SW} diretrory tree. A "make all" is exectuted before the actual installation is executed, i.e. before the files are copied.<br />
 In detail it will copy the executables in ${CHEOPS_SW}/bin, the library in ${CHEOPS_SW}/lib, the configuration files in ${CHEOPS_SW}/conf and the Python packages to ${CHEOPS_SW}/python. Furthermore it will copy the files definied by INSTALL_INCL in ${CHEOPS_SW}/include and will copy the files defined by INSTALL_RESOURCES in ${CHEOPS_SW}/resources.</p>
</li>
<li><p class="startli">make <b>unit_test</b> </p>
<p class="startli">will build and execute all C++ and Python unit tests. The C++ unit test programs have to be defined by the CXX_UNIT_TESTS variable in the makecheops file as a space seprated list of program names. For each program defined in the CXX_UNIT_TESTS variable a source file has to be available in the unit_test/src directory. It will be compiled and executed. A limitation is that the unit test program must be built from only one source file.</p>
<p class="startli">Similarly, the Python unit test modules have to be defined by the PYTHON_UNIT_TESTS variable. For each module name defined in PYTHON_UNIT_TESTS a corresponding Python script must be present in either unit_test/python or unit_test/bin. Python unit tests are executed using the Nose unit test framework.</p>
</li>
<li><p class="startli">make <b>functional_test</b> </p>
<p class="startli">will execute all functional test scripts. These scripts have to be defined by the FUNCTIONAL_TESTS variable in the makecheops file as space separated list of script files.</p>
</li>
<li><p class="startli">make <b>performance_test</b> </p>
<p class="startli">will execute all performance test scripts. These scripts have to be defined by the PERFORMANCE_TESTS variable in the makecheops file as space separated list of script files.</p>
</li>
<li><p class="startli">make <b>integration_test</b> </p>
<p class="startli">will execute all integration test scripts. These scripts have to be defined by the INTEGRATION_TESTS variable in the makecheops file as space separated list of script files.</p>
</li>
<li><p class="startli">make <b>tests</b> </p>
<p class="startli">will execute all tests. It is itentical to calling "make unit_test; make
     functional_test; make performance_test; make integration_test" . <br />
</p>
</li>
<li><p class="startli">make <b>coverage</b> </p>
<p class="startli">it is very similar as <b>make</b> <b>unit_test</b>. For C++, the software of the module is compiled with the -coverage option. Then the unit test programs are created and the tests are executed. Finally the web pages are created to show the code coverage of the module software. The top level web page is module/unit_test/cxxcoverge/index.html.</p>
<p class="startli">For Python, the unit tests are run with nosetest's &ndash;with-coverage option, and the resulting html report is located in module/unit_test/pycoverge/index.html.</p>
</li>
<li><p class="startli">make <b>coverage_jenkins</b> </p>
<p class="startli">it is very similar to <b>make</b> <b>coverage</b>, but instead of generating web pages it generates xml files containing coverage, unit test result and static code analysis results in a format that can be read by the Jenkins integration server.</p>
</li>
<li><p class="startli">make <b>doc</b> </p>
<p class="startli">will create the doxygen documentation of a product. A Doxyfile has to be available in the the sub-directory <em>doxygen</em> of the product. The "make doc" command has no affect if no doxygen sub-direcgtory exist or if no Doxyfile is available in such a sub-directory. The output directory into the created documentation files are create are defined inside of the Doxyfile. It should be doc/manual</p>
</li>
<li>make <b>make_update</b> <br />
 this target can be used to update the Makefile in all directories. First the master Makefile at common_sw/makefiles/resources/Makefile should be updated. Invoking "make install" will copy it to $CHEOPS_SW/resources. Now "make make_update" will copy the Makefile file from $CHEOPS_SW/resources to the current directory and all sub-directores defined by the variable SUBDIRS, see also chapter "Recursive calls of make in sub-directories". To update the Makefile in a full software directory tree the "make make_update" command should be executed at the top level directroy of the software directory tree.</li>
<li><p class="startli">make <b>release</b> </p>
<p class="startli">releases the software of one product. This target should be used carefully. It executes the release script $CHEOPS_SW/bin/release_cheops_package, which copies the trunk version of a product to a new tagged version in the svn repository and updates release number and date in the release note. Furthermore it creates the doxygen documentation and adds it to the tagged version. The release number is taken from the RELEASE_VERSION variable. <br />
</p>
</li>
</ul>
</li>
<li><p class="startli"><b> Recursive calls of make in sub-directories </b> <br />
 make can be executed recursively in a directory tree. With this feature it is possbile to build and install all modules of one product with one command. Even the full CHEOPS SOC software can be built at once. Nevertheless it is required that in each sub-directory at every level of the directory tree the files Makefile and makecheops are available. In the makcheops file the sub-directories, that should belong to the directory tree to be executed, are defined. The variable SUBDIRS has to list the sub-directories. For example </p><pre>
  SUBDIRS += module_1 module_2
  SUBDIRS += module_3  
  </pre><p class="startli">Besides the definition of the sub-directories any other variable can be defined in the same makecheops file to built for example a program. During the execution for one target first the sub-directories are processed and then the target in the current d directory is built.</p>
</li>
<li><p class="startli"><b> Python style documentation using Doxypypy </b> <br />
 Python code may be documented using Python style documentation with docstrings instead of the standard Doxygen format. This requires the use of a filter that converts Python style documentation to Doxygen style documentation, where the filter is a binary that must be available on the PATH.</p>
<p class="startli">This module contains a filter named py_filter which uses Doxypypy to perform this task. It is installed in the bin directory when 'make' is run. To enable the filter, the FILTER_PATTERNS parameter in the Doxygen configuration file must be updated: </p><pre>
  FILTER_PATTERNS        = *.py=py_filter
  </pre><p class="startli">For more information, see the <a href="https://github.com/Feneric/doxypypy">Doxypypy documentation</a> </p>
</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 11 2021 08:55:55 for Common Software by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
