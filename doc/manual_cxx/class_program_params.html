<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Common Software: ProgramParams Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cheops-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Common Software
   &#160;<span id="projectnumber">05</span>
   </div>
   <div id="projectbrief">Common Software for CHEOPS SOC - C++ API</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_program_params-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProgramParams Class Reference<div class="ingroups"><a class="el" href="group___prog_param.html">Program Parameter Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Top level interface class to access all parameters of a program.  
 <a href="class_program_params.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_program_params_8hxx_source.html">ProgramParams.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad4be327adff5dca9f0b4fef66e92c8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#ad4be327adff5dca9f0b4fef66e92c8dc">LogProgramParams</a> (const std::map&lt; std::string, std::string &gt; &amp;externalParams=std::map&lt; std::string, std::string &gt;())</td></tr>
<tr class="memdesc:ad4be327adff5dca9f0b4fef66e92c8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs all program parameters, including default values provided by the program parameter conf file, and input files.  <a href="#ad4be327adff5dca9f0b4fef66e92c8dc">More...</a><br /></td></tr>
<tr class="separator:ad4be327adff5dca9f0b4fef66e92c8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918da90a60092963bda18590849e1f57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a918da90a60092963bda18590849e1f57">ProgramParams</a> (int argc, char *argv[], const char *progName, const char *version)</td></tr>
<tr class="memdesc:a918da90a60092963bda18590849e1f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the parameter file the job order file and gets the command line parameters.  <a href="#a918da90a60092963bda18590849e1f57">More...</a><br /></td></tr>
<tr class="separator:a918da90a60092963bda18590849e1f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca91fffd336d8527c787f65d26eee408"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_module_params.html">ModuleParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#aca91fffd336d8527c787f65d26eee408">Module</a> (const std::string &amp;module) const</td></tr>
<tr class="memdesc:aca91fffd336d8527c787f65d26eee408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="class_module_params.html" title="A class to access all parameters and sub-modules of a module. ">ModuleParams</a> to access all parameters of a sub-module.  <a href="#aca91fffd336d8527c787f65d26eee408">More...</a><br /></td></tr>
<tr class="separator:aca91fffd336d8527c787f65d26eee408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9465277846c37736a34ffc18c3a7afb2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a9465277846c37736a34ffc18c3a7afb2">GetAsInt</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a9465277846c37736a34ffc18c3a7afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of an int32_t-parameter.  <a href="#a9465277846c37736a34ffc18c3a7afb2">More...</a><br /></td></tr>
<tr class="separator:a9465277846c37736a34ffc18c3a7afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5685a4c37a9067451efd2ad5e2fe1b4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#ad5685a4c37a9067451efd2ad5e2fe1b4">GetAsDouble</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ad5685a4c37a9067451efd2ad5e2fe1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a double-parameter.  <a href="#ad5685a4c37a9067451efd2ad5e2fe1b4">More...</a><br /></td></tr>
<tr class="separator:ad5685a4c37a9067451efd2ad5e2fe1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975d7fdeec0889d7d3d92aed70335d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a1975d7fdeec0889d7d3d92aed70335d5">GetAsBool</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1975d7fdeec0889d7d3d92aed70335d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a bool-parameter.  <a href="#a1975d7fdeec0889d7d3d92aed70335d5">More...</a><br /></td></tr>
<tr class="separator:a1975d7fdeec0889d7d3d92aed70335d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f911f3d7f51a28e76985cac8146e36"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#aa0f911f3d7f51a28e76985cac8146e36">GetAsString</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aa0f911f3d7f51a28e76985cac8146e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a string-parameter.  <a href="#aa0f911f3d7f51a28e76985cac8146e36">More...</a><br /></td></tr>
<tr class="separator:aa0f911f3d7f51a28e76985cac8146e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfac49408c179f692349a76981c69fca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#adfac49408c179f692349a76981c69fca">GetAsIntVector</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:adfac49408c179f692349a76981c69fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all values of a repeatable int-parameter.  <a href="#adfac49408c179f692349a76981c69fca">More...</a><br /></td></tr>
<tr class="separator:adfac49408c179f692349a76981c69fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65cfa4ea3aa5a43a1682a704baebef7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#ad65cfa4ea3aa5a43a1682a704baebef7">GetAsDoubleVector</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ad65cfa4ea3aa5a43a1682a704baebef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all values of a repeatable double-parameter.  <a href="#ad65cfa4ea3aa5a43a1682a704baebef7">More...</a><br /></td></tr>
<tr class="separator:ad65cfa4ea3aa5a43a1682a704baebef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc6451088fe1296df51e6a33d981547"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#aecc6451088fe1296df51e6a33d981547">GetAsBoolVector</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:aecc6451088fe1296df51e6a33d981547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all values of a repeatable bool-parameter.  <a href="#aecc6451088fe1296df51e6a33d981547">More...</a><br /></td></tr>
<tr class="separator:aecc6451088fe1296df51e6a33d981547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a148a9278e2b8a3c45973eca5791085"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a3a148a9278e2b8a3c45973eca5791085">GetAsStringVector</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a3a148a9278e2b8a3c45973eca5791085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all values of a repeatable string-parameter.  <a href="#a3a148a9278e2b8a3c45973eca5791085">More...</a><br /></td></tr>
<tr class="separator:a3a148a9278e2b8a3c45973eca5791085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596553acb6c5685a058b3804580ded0d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a596553acb6c5685a058b3804580ded0d">GetInputStructNames</a> ()</td></tr>
<tr class="memdesc:a596553acb6c5685a058b3804580ded0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all available input structure name, found in the job order file.  <a href="#a596553acb6c5685a058b3804580ded0d">More...</a><br /></td></tr>
<tr class="separator:a596553acb6c5685a058b3804580ded0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c84933f40b54f8e741b37bbbcd00e8d"><td class="memItemLeft" align="right" valign="top">const std::list&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a1c84933f40b54f8e741b37bbbcd00e8d">GetInputFiles</a> (const std::string &amp;dataStructName)</td></tr>
<tr class="memdesc:a1c84933f40b54f8e741b37bbbcd00e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all input file names of data structure <b>dataStructName</b>, found in the job order file.  <a href="#a1c84933f40b54f8e741b37bbbcd00e8d">More...</a><br /></td></tr>
<tr class="separator:a1c84933f40b54f8e741b37bbbcd00e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37954163234ff0b7a91b6bc806926b06"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a37954163234ff0b7a91b6bc806926b06">GetOutDir</a> () const</td></tr>
<tr class="memdesc:a37954163234ff0b7a91b6bc806926b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output directory that shall be used to store all files, that shall be archived.  <a href="#a37954163234ff0b7a91b6bc806926b06">More...</a><br /></td></tr>
<tr class="separator:a37954163234ff0b7a91b6bc806926b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc23bff1b00df9f0eb2f3fec7471fbb4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#abc23bff1b00df9f0eb2f3fec7471fbb4">GetTmpDir</a> () const</td></tr>
<tr class="memdesc:abc23bff1b00df9f0eb2f3fec7471fbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a temporary directory that should be used to store all files that can be deleted after the execution of the program.  <a href="#abc23bff1b00df9f0eb2f3fec7471fbb4">More...</a><br /></td></tr>
<tr class="separator:abc23bff1b00df9f0eb2f3fec7471fbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3abb4aeacdf61916deeb75c2bdf9256c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a3abb4aeacdf61916deeb75c2bdf9256c">ReadJobOrderFile</a> (const std::string &amp;jobOrderFileName)</td></tr>
<tr class="memdesc:a3abb4aeacdf61916deeb75c2bdf9256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the job order file and stores the filenames in m_inputFiles and m_outputFiles.  <a href="#a3abb4aeacdf61916deeb75c2bdf9256c">More...</a><br /></td></tr>
<tr class="separator:a3abb4aeacdf61916deeb75c2bdf9256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ef11f20d72663e2c505e17cc038290"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a88ef11f20d72663e2c505e17cc038290">ReadParamFile</a> (const std::string &amp;programName, boost::program_options::options_description &amp;desc)</td></tr>
<tr class="memdesc:a88ef11f20d72663e2c505e17cc038290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the parameter file and stores them in desc.  <a href="#a88ef11f20d72663e2c505e17cc038290">More...</a><br /></td></tr>
<tr class="separator:a88ef11f20d72663e2c505e17cc038290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d3c04a1c1a2f0afbeada16088ffccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#af5d3c04a1c1a2f0afbeada16088ffccd">ReadModule</a> (const std::string &amp;path, const module_type &amp;module, boost::program_options::options_description &amp;desc)</td></tr>
<tr class="memdesc:af5d3c04a1c1a2f0afbeada16088ffccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the parameters of one module and stores them in desc.  <a href="#af5d3c04a1c1a2f0afbeada16088ffccd">More...</a><br /></td></tr>
<tr class="separator:af5d3c04a1c1a2f0afbeada16088ffccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bde150409712672f9f666cf5176977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a87bde150409712672f9f666cf5176977">ReadParam</a> (const std::string &amp;path, const param_type &amp;param, boost::program_options::options_description &amp;desc)</td></tr>
<tr class="memdesc:a87bde150409712672f9f666cf5176977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one parameter form the parameter file and stores its attributes in desc.  <a href="#a87bde150409712672f9f666cf5176977">More...</a><br /></td></tr>
<tr class="separator:a87bde150409712672f9f666cf5176977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b28f24117c6640f9a8c95b7d62b5732"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a4b28f24117c6640f9a8c95b7d62b5732">ProgramParams</a> (const <a class="el" href="class_program_params.html">ProgramParams</a> &amp;)</td></tr>
<tr class="memdesc:a4b28f24117c6640f9a8c95b7d62b5732"><td class="mdescLeft">&#160;</td><td class="mdescRight">There exist no implementation. It cannot be used.  <a href="#a4b28f24117c6640f9a8c95b7d62b5732">More...</a><br /></td></tr>
<tr class="separator:a4b28f24117c6640f9a8c95b7d62b5732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486930d832af8c703bb10290db3fc247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_program_params.html">ProgramParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a486930d832af8c703bb10290db3fc247">operator=</a> (const <a class="el" href="class_program_params.html">ProgramParams</a> &amp;)</td></tr>
<tr class="memdesc:a486930d832af8c703bb10290db3fc247"><td class="mdescLeft">&#160;</td><td class="mdescRight">There exist no implementation. It cannot be used.  <a href="#a486930d832af8c703bb10290db3fc247">More...</a><br /></td></tr>
<tr class="separator:a486930d832af8c703bb10290db3fc247"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a281d9b04c54e80fb4ad3807de3649a8f"><td class="memItemLeft" align="right" valign="top"><a id="a281d9b04c54e80fb4ad3807de3649a8f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a281d9b04c54e80fb4ad3807de3649a8f">m_progName</a></td></tr>
<tr class="memdesc:a281d9b04c54e80fb4ad3807de3649a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of current program, set in the constructor. <br /></td></tr>
<tr class="separator:a281d9b04c54e80fb4ad3807de3649a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279a63974c2afa6f1380cba1dd450e57"><td class="memItemLeft" align="right" valign="top"><a id="a279a63974c2afa6f1380cba1dd450e57"></a>
boost::program_options::variables_map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a279a63974c2afa6f1380cba1dd450e57">m_params</a></td></tr>
<tr class="memdesc:a279a63974c2afa6f1380cba1dd450e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">All program parameters. <br /></td></tr>
<tr class="separator:a279a63974c2afa6f1380cba1dd450e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523d3604d38a01ec0a22469bdc8d8506"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a523d3604d38a01ec0a22469bdc8d8506">m_jobOrderParams</a></td></tr>
<tr class="memdesc:a523d3604d38a01ec0a22469bdc8d8506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters defined in the job order file.  <a href="#a523d3604d38a01ec0a22469bdc8d8506">More...</a><br /></td></tr>
<tr class="separator:a523d3604d38a01ec0a22469bdc8d8506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a5dc53234321a3965d014a55e3226"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::list&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a726a5dc53234321a3965d014a55e3226">m_inputFiles</a></td></tr>
<tr class="memdesc:a726a5dc53234321a3965d014a55e3226"><td class="mdescLeft">&#160;</td><td class="mdescRight">All input FITS extensions for the current task as defined in the job order file.  <a href="#a726a5dc53234321a3965d014a55e3226">More...</a><br /></td></tr>
<tr class="separator:a726a5dc53234321a3965d014a55e3226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1272da05987b5b4d71319fbef447fa3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#a1272da05987b5b4d71319fbef447fa3a">m_outDir</a></td></tr>
<tr class="memdesc:a1272da05987b5b4d71319fbef447fa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output directory for the current task as defined in the job order file.  <a href="#a1272da05987b5b4d71319fbef447fa3a">More...</a><br /></td></tr>
<tr class="separator:a1272da05987b5b4d71319fbef447fa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae072737fd5acc7373500ca8adb44a0f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_program_params.html#aae072737fd5acc7373500ca8adb44a0f">m_tmpDir</a></td></tr>
<tr class="memdesc:aae072737fd5acc7373500ca8adb44a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tmp directory for the current task as defined in the job order file.  <a href="#aae072737fd5acc7373500ca8adb44a0f">More...</a><br /></td></tr>
<tr class="separator:aae072737fd5acc7373500ca8adb44a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Top level interface class to access all parameters of a program. </p>
<hr/>
<dl class="section author"><dt>Author</dt><dd>Reiner Rohlfs UGE</dd></dl>
<p>An application program should not create an instance of this class by itself, instead it shall call the <a class="el" href="group___prog_param.html#gac588050f01e813c2a25336cb967f20b5" title="Initializes various infrastructure modules using the program arguments. ">CheopsInit()</a> function, which returns a smart pointer of this class.<br />
</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a918da90a60092963bda18590849e1f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918da90a60092963bda18590849e1f57">&#9670;&nbsp;</a></span>ProgramParams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ProgramParams::ProgramParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>progName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the parameter file the job order file and gets the command line parameters. </p>
<hr/>
<hr/>
<p> Reads the XML parameter file and overwrites the parameter values with the values given in the command line. The input and output file names are read from the job order file. The job order filename has to be specified on the command line as a parameter and not as an option. For example: program_name job_order_file_name</p>
<p>Prints a help text with a short documentation of every parameter if the user specifies the <code>-h</code> or <code>--help</code> option. Prints the version of the program if the user specifies the <code>-v</code> or <code>--version</code> option. After printing the help text or the version number it terminates the program by calling exit(0);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>number of arguments in argv, should be copied directly from the <a class="el" href="_fits_data_model_8cxx.html#a0ddf1224851353fc92bfbff6f499fa97" title="main function of the fits_data_model program ">main()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>list of command line parameters. Should be copied directly from the <a class="el" href="_fits_data_model_8cxx.html#a0ddf1224851353fc92bfbff6f499fa97" title="main function of the fits_data_model program ">main()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">progName</td><td>name of the program. It is used to find the parameter file, which has to have the file name progName.xml. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">version</td><td>the version number of the program. Will be printed by calling the program with the <code>-v</code> or <code>--version</code> option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if something fails. For example:<ul>
<li>the xml file cannot be read</li>
<li>the xml schema cannot be read</li>
<li>the xml file is not fully valid</li>
<li>a not defined parameter is given in the command line</li>
<li>a parameter value cannot be converted in its data type </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b28f24117c6640f9a8c95b7d62b5732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b28f24117c6640f9a8c95b7d62b5732">&#9670;&nbsp;</a></span>ProgramParams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ProgramParams::ProgramParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_program_params.html">ProgramParams</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There exist no implementation. It cannot be used. </p>
<hr/>
 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1975d7fdeec0889d7d3d92aed70335d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975d7fdeec0889d7d3d92aed70335d5">&#9670;&nbsp;</a></span>GetAsBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ProgramParams::GetAsBool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a bool-parameter. </p>
<hr/>
<hr/>
<p> The value of parameters with data type == <b>bool</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.<br />
Following case insensitive strings are interpreted as true:<br />
 "true", "on", "yes", "1".<br />
Following case insensitive strings are interpreted as false:<br />
 "false", "off", "no", "0".<br />
 The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist or if the value of the parameter cannot be understood to be a bool variable. </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type bool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="aecc6451088fe1296df51e6a33d981547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc6451088fe1296df51e6a33d981547">&#9670;&nbsp;</a></span>GetAsBoolVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; ProgramParams::GetAsBoolVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all values of a repeatable bool-parameter. </p>
<hr/>
<hr/>
<p> Repeatable parameters are parameters that can be given multiple times on the command line. The values of all occurrences of a repeatable parameter are returned as a vector.</p>
<p>The value of repeatable parameters with data type == <b>bool</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>Following case insensitive strings are interpreted as true:<br />
 "true", "on", "yes", "1".<br />
Following case insensitive strings are interpreted as false:<br />
 "false", "off", "no", "0".<br />
 The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<p>NOTE: monitor4EO does not allow that a parameter is defined multiple times in the job order. Therefore, to specify multiple values for a parameter in the job order, all values must be put into the Value element of the parameter, separated by whitespace and/or commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist or if the value of the parameter cannot be understood to be a bool variable. </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type bool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="ad5685a4c37a9067451efd2ad5e2fe1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5685a4c37a9067451efd2ad5e2fe1b4">&#9670;&nbsp;</a></span>GetAsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ProgramParams::GetAsDouble </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a double-parameter. </p>
<hr/>
<hr/>
<p> The value of parameters with data type == <b>double</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist or if the value of the parameter cannot be converted into a double variable. </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type double</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="ad65cfa4ea3aa5a43a1682a704baebef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65cfa4ea3aa5a43a1682a704baebef7">&#9670;&nbsp;</a></span>GetAsDoubleVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; ProgramParams::GetAsDoubleVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all values of a repeatable double-parameter. </p>
<hr/>
<hr/>
<p> Repeatable parameters are parameters that can be given multiple times on the command line. The values of all occurrences of a repeatable parameter are returned as a vector.</p>
<p>The value of repeatable parameters with data type == <b>double</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<p>NOTE: monitor4EO does not allow that a parameter is defined multiple times in the job order. Therefore, to specify multiple values for a parameter in the job order, all values must be put into the Value element of the parameter, separated by whitespace and/or commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist or if the value of the parameter cannot be converted into a double variable. </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type double</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="a9465277846c37736a34ffc18c3a7afb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9465277846c37736a34ffc18c3a7afb2">&#9670;&nbsp;</a></span>GetAsInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ProgramParams::GetAsInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of an int32_t-parameter. </p>
<hr/>
<hr/>
<p> The value of parameters with data type == <b>int32_t</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist or if the value of the parameter cannot be converted into a int32_t variable. </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type int32_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="adfac49408c179f692349a76981c69fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfac49408c179f692349a76981c69fca">&#9670;&nbsp;</a></span>GetAsIntVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; ProgramParams::GetAsIntVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all values of a repeatable int-parameter. </p>
<hr/>
<hr/>
<p> Repeatable parameters are parameters that can be given multiple times on the command line. The values of all occurrences of a repeatable parameter are returned as a vector.</p>
<p>The value of repeatable parameters with data type == <b>int32_t</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<p>NOTE: monitor4EO does not allow that a parameter is defined multiple times in the job order. Therefore, to specify multiple values for a parameter in the job order, all values must be put into the Value element of the parameter, separated by whitespace and/or commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist or if the value of the parameter cannot be converted into a int32_t variable. </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type int32_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="aa0f911f3d7f51a28e76985cac8146e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f911f3d7f51a28e76985cac8146e36">&#9670;&nbsp;</a></span>GetAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ProgramParams::GetAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of a string-parameter. </p>
<hr/>
<hr/>
<p> The value of parameters with data type == <b>string</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="a3a148a9278e2b8a3c45973eca5791085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a148a9278e2b8a3c45973eca5791085">&#9670;&nbsp;</a></span>GetAsStringVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; ProgramParams::GetAsStringVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all values of a repeatable string-parameter. </p>
<hr/>
<hr/>
<p> Repeatable parameters are parameters that can be given multiple times on the command line. The values of all occurrences of a repeatable parameter are returned as a vector.</p>
<p>The value of repeatable parameters with data type == <b>string</b> can be accessed with this function. Note: the data type is defined in the XML parameter file.</p>
<p>The method will first look for the parameter in the job order file and return it if found. Otherwise, it looks in the parameter file and command line parameters. If it is not found, an exception is thrown.</p>
<p>NOTE: monitor4EO does not allow that a parameter is defined multiple times in the job order. Therefore, to specify multiple values for a parameter in the job order, all values must be put into the Value element of the parameter, separated by whitespace and/or commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>the full name of a parameter. If the parameter is defined in a module or sub-module the module name must be part of the <b>name</b>. For example: <code>"module.sub-module.parameter"</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter <b>name</b> does not exist </td></tr>
    <tr><td class="paramname">exception</td><td>if the parameter <b>name</b> is not of data type string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the parameter. </dd></dl>

</div>
</div>
<a id="a1c84933f40b54f8e741b37bbbcd00e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c84933f40b54f8e741b37bbbcd00e8d">&#9670;&nbsp;</a></span>GetInputFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; std::string &gt; &amp; ProgramParams::GetInputFiles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dataStructName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all input file names of data structure <b>dataStructName</b>, found in the job order file. </p>
<hr/>
<hr/>
 <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the data structure is not defined in the job order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a596553acb6c5685a058b3804580ded0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596553acb6c5685a058b3804580ded0d">&#9670;&nbsp;</a></span>GetInputStructNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const set&lt; string &gt; ProgramParams::GetInputStructNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all available input structure name, found in the job order file. </p>
<hr/>
<hr/>
<p> The structure names in the returned list can be used as input parameter of the <a class="el" href="class_program_params.html#a1c84933f40b54f8e741b37bbbcd00e8d" title="Returns a list of all input file names of data structure dataStructName, found in the job order file...">GetInputFiles()</a> method to retrieve all file names of a given data structure.</p>
<dl class="section return"><dt>Returns</dt><dd>List of all available input structure names in the job order file. </dd></dl>

</div>
</div>
<a id="a37954163234ff0b7a91b6bc806926b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37954163234ff0b7a91b6bc806926b06">&#9670;&nbsp;</a></span>GetOutDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ProgramParams::GetOutDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the output directory that shall be used to store all files, that shall be archived. </p>
<hr/>
<p> If the program runs successfully, these files will be archived by the Monitor4EO framework after the program has terminated. </p>

</div>
</div>
<a id="abc23bff1b00df9f0eb2f3fec7471fbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc23bff1b00df9f0eb2f3fec7471fbb4">&#9670;&nbsp;</a></span>GetTmpDir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ProgramParams::GetTmpDir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a temporary directory that should be used to store all files that can be deleted after the execution of the program. </p>
<hr/>
<p> If is read from the job-order file. The "File_TYPE" in the job-order file is TMP and the "File_Name_Type" is Directory. All files, stored in this directory will be deleted by the Monitor4EO framework after the execution of the program. </p>

</div>
</div>
<a id="ad4be327adff5dca9f0b4fef66e92c8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4be327adff5dca9f0b4fef66e92c8dc">&#9670;&nbsp;</a></span>LogProgramParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ProgramParams::LogProgramParams </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>externalParams</em> = <code>std::map&lt;std::string,&#160;std::string&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logs all program parameters, including default values provided by the program parameter conf file, and input files. </p>
<hr/>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">externalParams</td><td>optional argument for passing in additional key/value pairs to be written to the "Program
                           Parameters" section of the log file in addition to those defined in the job order, on the command line or in the config file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca91fffd336d8527c787f65d26eee408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca91fffd336d8527c787f65d26eee408">&#9670;&nbsp;</a></span>Module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_module_params.html">ModuleParams</a> ProgramParams::Module </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="class_module_params.html" title="A class to access all parameters and sub-modules of a module. ">ModuleParams</a> to access all parameters of a sub-module. </p>
<hr/>
<hr/>
<p> The parameters (and sub-modules) of <b>module</b> can be accessed with the returned <a class="el" href="class_module_params.html" title="A class to access all parameters and sub-modules of a module. ">ModuleParams</a> without specifying the <b>module</b> name in its path. See also Detailed Description of <a class="el" href="class_module_params.html" title="A class to access all parameters and sub-modules of a module. ">ModuleParams</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>name of the module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486930d832af8c703bb10290db3fc247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486930d832af8c703bb10290db3fc247">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_program_params.html">ProgramParams</a>&amp; ProgramParams::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_program_params.html">ProgramParams</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There exist no implementation. It cannot be used. </p>
<hr/>
 
</div>
</div>
<a id="a3abb4aeacdf61916deeb75c2bdf9256c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abb4aeacdf61916deeb75c2bdf9256c">&#9670;&nbsp;</a></span>ReadJobOrderFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProgramParams::ReadJobOrderFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>jobOrderFileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the job order file and stores the filenames in m_inputFiles and m_outputFiles. </p>
<hr/>
<hr/>
<p> Parses the job order file, using the xsd library and looks for the section where the input and output files for this program are defined. The program name is a parameter to the constructor of <a class="el" href="class_program_params.html" title="Top level interface class to access all parameters of a program. ">ProgramParams</a>. Only the files specified for this program are read and stored in m_inputFiles and m_outputFiles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobOrderFileName</td><td>name of the job order file</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the job order file does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d3c04a1c1a2f0afbeada16088ffccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d3c04a1c1a2f0afbeada16088ffccd">&#9670;&nbsp;</a></span>ReadModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProgramParams::ReadModule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const module_type &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::program_options::options_description &amp;&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the parameters of one module and stores them in desc. </p>
<hr/>
<hr/>
<p> If first process all parameter of this module and processes than all sub-modules of this module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The parent modules of this new module. May be empty if this module does not belong to a module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Gives access to all parameters and sub-modules of this module, as defined in the xml parameter file. It is filled by while the xml file was parsed with the xsd library. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>All new parameter of this module and all sub-modules are added to this variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87bde150409712672f9f666cf5176977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bde150409712672f9f666cf5176977">&#9670;&nbsp;</a></span>ReadParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProgramParams::ReadParam </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const param_type &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::program_options::options_description &amp;&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads one parameter form the parameter file and stores its attributes in desc. </p>
<hr/>
<hr/>
<p> Converts the attributes of one parameter form the xml file into a semantic variable and adds it to <b>desc</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The parent modules of this new parameter. May be empty if the parameter does not belong to a module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Gives access to all attributes of the parameter, as defined in the xml parameter file. It is filled by while the xml file was parsed with the xsd library. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>The new parameter is added to this variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ef11f20d72663e2c505e17cc038290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ef11f20d72663e2c505e17cc038290">&#9670;&nbsp;</a></span>ReadParamFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ProgramParams::ReadParamFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>programName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::program_options::options_description &amp;&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the parameter file and stores them in desc. </p>
<hr/>
<hr/>
<p> First the function tries to open the parameter file in these locations:</p><ol type="1">
<li>in the current directory</li>
<li>in the conf sub-directory of the current directory</li>
<li>in the ${CHOPS_SW}/conf directory.</li>
</ol>
<p>Then is uses the XSD library to pars the parameter file and calls functions to store all parameters in <b>desc</b>.</p>
<p>The filename (without path) of the parameter file is programName.xml</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">programName</td><td>It is used to define the file name of the parameter file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>All parameters with their attributes are stored in the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>if the parameter file cannot be found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a726a5dc53234321a3965d014a55e3226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a5dc53234321a3965d014a55e3226">&#9670;&nbsp;</a></span>m_inputFiles</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::list&lt;std::string&gt; &gt; ProgramParams::m_inputFiles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All input FITS extensions for the current task as defined in the job order file. </p>
<hr/>
<p> The key of the map is the File_Type in the job order, which is identical to a FITS data structure name. The value of the map is a list of all FITS extensions found in the job order belonging to that File_Type, i.e. which are constructed with that FITS data structure. </p>

</div>
</div>
<a id="a523d3604d38a01ec0a22469bdc8d8506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523d3604d38a01ec0a22469bdc8d8506">&#9670;&nbsp;</a></span>m_jobOrderParams</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, std::string&gt; ProgramParams::m_jobOrderParams</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameters defined in the job order file. </p>
<hr/>
<p> The key is either the value of the Name element if the parameter comes from the dynamic processing parameters, otherwise it is the name of the element containing the value. </p>

</div>
</div>
<a id="a1272da05987b5b4d71319fbef447fa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1272da05987b5b4d71319fbef447fa3a">&#9670;&nbsp;</a></span>m_outDir</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ProgramParams::m_outDir</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The output directory for the current task as defined in the job order file. </p>
<hr/>
 
</div>
</div>
<a id="aae072737fd5acc7373500ca8adb44a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae072737fd5acc7373500ca8adb44a0f">&#9670;&nbsp;</a></span>m_tmpDir</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ProgramParams::m_tmpDir</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The tmp directory for the current task as defined in the job order file. </p>
<hr/>
 
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>program_params/include/<a class="el" href="_program_params_8hxx_source.html">ProgramParams.hxx</a></li>
<li>program_params/include/<a class="el" href="_program_params_inl_8hxx_source.html">ProgramParamsInl.hxx</a></li>
<li>program_params/src/<a class="el" href="_program_params_8cxx.html">ProgramParams.cxx</a></li>
<li>program_params/src/<a class="el" href="_read_job_order_file_8cxx.html">ReadJobOrderFile.cxx</a></li>
<li>program_params/src/<a class="el" href="_read_param_file_8cxx.html">ReadParamFile.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 11 2021 08:55:59 for Common Software by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
